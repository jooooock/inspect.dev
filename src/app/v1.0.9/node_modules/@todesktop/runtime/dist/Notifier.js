"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const electron_1 = require("electron");
/**
 * A proxy to a real Electron API.
 * This class could be replaced by a mock for unit testing
 */
class ElectronApi {
    getAppName() {
        return (electron_1.app === null || electron_1.app === void 0 ? void 0 : electron_1.app.name) || "this application";
    }
    isAppInForeground() {
        return Boolean(electron_1.BrowserWindow.getFocusedWindow());
    }
    showMessageBox(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return electron_1.dialog.showMessageBox(options);
        });
    }
    showNotification(options) {
        const notification = new electron_1.Notification(options);
        notification.show();
        return notification;
    }
}
class Notifier {
    constructor({ autoUpdater, electronApi = new ElectronApi(), updateReadyAction, }) {
        this._lastUpdate = { isProcessing: false, version: "" };
        this._onNotifyAfterUpdateDownloaded = this._onNotifyAfterUpdateDownloaded.bind(this);
        this._autoUpdater = autoUpdater;
        this._electronApi = electronApi;
        this._updateReadyAction = Object.assign({ showInstallAndRestartPrompt: "never", showNotification: "always" }, updateReadyAction);
        if (typeof (autoUpdater === null || autoUpdater === void 0 ? void 0 : autoUpdater.on) !== "function") {
            throw new Error("Invalid autoUpdater instance");
        }
        autoUpdater.on("notify-after-update-downloaded", this._onNotifyAfterUpdateDownloaded);
    }
    _onNotifyAfterUpdateDownloaded(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._lastUpdate.isProcessing ||
                this._lastUpdate.version === payload.updateInfo.version) {
                return;
            }
            this._lastUpdate = {
                isProcessing: true,
                version: payload.updateInfo.version,
            };
            try {
                yield this._showNotification(payload);
                yield this._showInstallAndRestartPrompt(payload);
                this._lastUpdate.isProcessing = false;
            }
            catch (_a) {
                this._lastUpdate.isProcessing = false;
            }
        });
    }
    _showInstallAndRestartPrompt(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const mode = this._updateReadyAction.showInstallAndRestartPrompt;
            const appName = this._electronApi.getAppName();
            if (mode === "never") {
                return;
            }
            const appIsInForeground = this._electronApi.isAppInForeground();
            if (mode === "whenInForeground" && !appIsInForeground) {
                return;
            }
            const prompt = typeof mode === "function"
                ? yield mode(Object.assign(Object.assign({}, payload), { appIsInForeground }))
                : undefined;
            if (typeof prompt === "function") {
                yield prompt({
                    showInstallAndRestartPrompt: (...args) => this._electronApi.showMessageBox(...args),
                    restartAndInstall: (...args) => this._autoUpdater.restartAndInstall(...args),
                });
            }
            else if (prompt) {
                const { installOnNextLaunchButton, restartAndInstallButton } = prompt, props = __rest(prompt, ["installOnNextLaunchButton", "restartAndInstallButton"]);
                const { response } = yield this._electronApi.showMessageBox(Object.assign(Object.assign({}, props), { buttons: [installOnNextLaunchButton, restartAndInstallButton] }));
                if (response === 1) {
                    this._autoUpdater.restartAndInstall();
                }
            }
            else if (mode === "whenInForeground" || mode === "always") {
                const { response } = yield this._electronApi.showMessageBox({
                    message: "Update Available",
                    detail: `A new version of ${appName} is ready to be installed.`,
                    buttons: [
                        "Install on next launch",
                        `Install now and restart ${appName}`,
                    ],
                });
                if (response === 1) {
                    this._autoUpdater.restartAndInstall();
                }
            }
        });
    }
    _showNotification(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const mode = this._updateReadyAction.showNotification;
            const appName = this._electronApi.getAppName();
            if (mode === "never") {
                return;
            }
            const appIsInForeground = this._electronApi.isAppInForeground();
            if (mode === "whenInBackground" && appIsInForeground) {
                return;
            }
            const notification = typeof mode === "function"
                ? yield mode(Object.assign(Object.assign({}, payload), { appIsInForeground }))
                : undefined;
            if (typeof notification === "function") {
                yield notification({
                    showNotification: (...args) => this._electronApi.showNotification(...args),
                });
            }
            else if (notification) {
                this._electronApi.showNotification(notification);
            }
            else if (mode === "whenInBackground" || mode === "always") {
                this._electronApi.showNotification({
                    title: "A new update is ready to install",
                    body: `${appName} version ${payload.updateInfo.version} has been ` +
                        "downloaded and will be automatically installed on exit",
                });
            }
        });
    }
}
exports.default = Notifier;
