"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimulatedAutoUpdater = exports.parseSimulateUpdatesFlag = exports.SimulateUpdatesFlag = void 0;
const electron_1 = require("electron");
const eventemitter2_1 = require("eventemitter2");
const types_1 = require("./types");
function delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
var SimulateUpdatesFlag;
(function (SimulateUpdatesFlag) {
    SimulateUpdatesFlag["UpdateAvailable"] = "update-available";
    SimulateUpdatesFlag["UpdateNotAvailable"] = "update-not-available";
})(SimulateUpdatesFlag = exports.SimulateUpdatesFlag || (exports.SimulateUpdatesFlag = {}));
const parseSimulateUpdatesFlag = () => {
    const flag = process.argv.find((flag) => flag.includes("--runtime-simulate-updates"));
    if (!flag)
        return null;
    const value = flag.split("=")[1];
    if (!Object.values(SimulateUpdatesFlag).includes(value)) {
        throw new Error(`--runtime-simulate-updates expects a mode value of "${SimulateUpdatesFlag.UpdateAvailable}" or "${SimulateUpdatesFlag.UpdateNotAvailable}". Received "${value}"`);
    }
    return value;
};
exports.parseSimulateUpdatesFlag = parseSimulateUpdatesFlag;
class SimulatedAutoUpdater extends eventemitter2_1.EventEmitter2 {
    constructor({ autoCheckInterval = 10 * 60 * 1000, // 10 min
    logger, shouldAutoCheckOnLaunch = true, }) {
        super();
        this.simulateUpdatesFlag = (0, exports.parseSimulateUpdatesFlag)();
        this.hasUpdateReadyToInstall = false;
        this.checkForUpdates = ({ source = types_1.BuiltInSources.programmaticCall, disableUpdateReadyAction = false, } = {}) => __awaiter(this, void 0, void 0, function* () {
            this.logger.info("checkForUpdates()", { source });
            const tdUpdateInfo = {
                releaseDate: new Date().toISOString(),
                version: `${electron_1.app.getVersion()}-simulated`,
            };
            const info = Object.assign(Object.assign({}, tdUpdateInfo), { files: [], path: "", sha512: "" });
            this.emit("checking-for-update");
            yield delay(1000);
            if (this.simulateUpdatesFlag === SimulateUpdatesFlag.UpdateNotAvailable) {
                this.emit("update-not-available", info);
                return { updateInfo: null };
            }
            else {
                this.emit("update-available", info);
                const getProgressInfo = (percent) => __awaiter(this, void 0, void 0, function* () {
                    const totalBytes = 1000000; // 100 mb
                    return {
                        total: totalBytes,
                        percent,
                        transferred: (percent / 100) * totalBytes,
                        delta: 1000000 / 10,
                        bytesPerSecond: totalBytes / 5, // total transfer time is hardcoded to 5 seconds, so divide
                    };
                });
                for (const percentage of [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) {
                    yield delay(500);
                    this.emit("download-progress", yield getProgressInfo(percentage));
                }
                this.hasUpdateReadyToInstall = true;
                const eventPayload = {
                    sources: [source],
                    updateInfo: info,
                    disableUpdateReadyAction,
                };
                this.emit("update-downloaded", eventPayload);
                this.emit("notify-after-update-downloaded", eventPayload);
                return { updateInfo: tdUpdateInfo };
            }
        });
        this.restartAndInstall = ({ isSilent = false, } = {}) => {
            this.logger.info("restartAndInstall()", { isSilent });
            if (!this.hasUpdateReadyToInstall) {
                const error = new Error("Cannot restart and install. There is no update downloaded");
                this.logger.error("error", error);
                throw error;
            }
            this.emit("before-quit-for-update");
            delay(1000).then(() => {
                electron_1.app.relaunch({
                    args: [
                        `--runtime-simulate-updates=${SimulateUpdatesFlag.UpdateNotAvailable}`,
                    ],
                });
                electron_1.app.quit();
            });
        };
        this.setFeedURL = (...args) => {
            this.logger.info("setFeedURL()", args);
            this.logger.warn("setFeedURL() doesn't do anything in simulated mode.");
        };
        this.logger = logger;
        electron_1.app.on("will-finish-launching", () => {
            if (autoCheckInterval > 0) {
                const interval = setInterval(() => {
                    this.checkForUpdates({ source: types_1.BuiltInSources.autoCheckOnInterval });
                    // interval should be cleared once a prompt is shown, otherwise will re-prompt every interval
                    if (this.simulateUpdatesFlag === SimulateUpdatesFlag.UpdateAvailable) {
                        clearInterval(interval);
                    }
                }, autoCheckInterval);
            }
            if (shouldAutoCheckOnLaunch) {
                this.checkForUpdates({ source: types_1.BuiltInSources.autoCheckOnLaunch });
            }
        });
    }
}
exports.SimulatedAutoUpdater = SimulatedAutoUpdater;
