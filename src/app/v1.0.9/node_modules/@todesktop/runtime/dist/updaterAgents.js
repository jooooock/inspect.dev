"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SquirrelWindowsUpdaterAgent = exports.UpdaterAgent = void 0;
const del = require("del");
const electron = require("electron");
const electronUpdater = require("electron-updater");
const execa = require("execa");
const fs = require("fs");
const once = require("lodash.once");
const os = require("os");
const path = require("path");
const semver = require("semver");
const getConfig_1 = require("./getConfig");
const getPackageJson_1 = require("./getPackageJson");
class UpdaterAgent {
    constructor({ log, logger, }) {
        this.currentTDUpdateInfo = null;
        this._log = (level, ...args) => log(level, "UpdaterAgent:", ...args);
        // electron-updater will use this logger (includes the user's custom one)
        electronUpdater.autoUpdater.logger = logger;
        electronUpdater.autoUpdater.allowDowngrade = true;
        const config = (0, getConfig_1.default)();
        /*
          Even if a Mac app wasn't built by us, we can update it if we use
          electron-updater and point to our server
        */
        if (process.platform === "darwin" && !config.wasBuiltByUs) {
            electronUpdater.autoUpdater.setFeedURL(`https://download.todesktop.com/${config.id}`);
        }
        /*
          When transitioning from Squirrel.Windows to NSIS, the NSIS app
          will import runtime and this will uninstall and clean up the
          old Squirrel.Windows app.
          See https://github.com/electron-userland/electron-builder/issues/837
        */
        if (process.platform === "win32" && config.wasBuiltByUs) {
            this._uninstallSquirrelWindowsAppIfItExists();
        }
    }
    checkAndDownload() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                electronUpdater.autoUpdater.autoDownload = false;
                const updateCheckResult = yield electronUpdater.autoUpdater.checkForUpdates();
                // No update available?
                if (!updateCheckResult || !updateCheckResult.updateInfo) {
                    return null;
                }
                // We need to make sure the version is actually newer
                const currentVersion = electron.app.getVersion();
                const latestVersion = updateCheckResult.updateInfo.version;
                const currentlyDownloadedVersion = (_a = this.currentTDUpdateInfo) === null || _a === void 0 ? void 0 : _a.version;
                this._log("debug", "Analysing autoUpdater.checkForUpdates result", {
                    currentVersion,
                    latestVersion,
                    currentlyDownloadedVersion,
                    updateInfo: updateCheckResult.updateInfo,
                });
                // if latest version is already downloaded, return it
                if (currentlyDownloadedVersion === latestVersion) {
                    return this.currentTDUpdateInfo;
                }
                // autoUpdater provides a cancellationToken if an update is available - https://github.com/electron-userland/electron-builder/blob/906ffb1fcebe6aef4dc6c6a3fab10aa7d9378c3f/packages/electron-updater/src/AppUpdater.ts#L422
                if (!updateCheckResult.cancellationToken) {
                    return this.currentTDUpdateInfo;
                }
                yield electronUpdater.autoUpdater.downloadUpdate(updateCheckResult.cancellationToken);
                this.currentTDUpdateInfo = this._convertToTDUpdateInfo(updateCheckResult);
                return this.currentTDUpdateInfo;
            }
            catch (e) {
                if (e.name === "CancellationError") {
                    throw new Error("Update check cancelled");
                }
                throw e;
            }
        });
    }
    restartAndInstall(isSilent, isForceRunAfter) {
        electronUpdater.autoUpdater.quitAndInstall(isSilent, isForceRunAfter);
    }
    setFeedURL(options) {
        this._log("debug", "_setFeedURL()", options);
        electronUpdater.autoUpdater.setFeedURL(options);
    }
    _convertToTDUpdateInfo(updateCheckResult) {
        return {
            releaseDate: updateCheckResult.updateInfo.releaseDate,
            version: updateCheckResult.updateInfo.version,
        };
    }
    _uninstallSquirrelWindowsAppIfItExists() {
        return __awaiter(this, void 0, void 0, function* () {
            this._log("debug", "_uninstallSquirrelWindowsAppIfItExists()");
            try {
                const pathToAppDirectory = path.join(os.homedir(), "AppData", "Local", (0, getPackageJson_1.default)().name);
                /*
                  The NSIS installer checks if there's a Squirrel.Windows app
                  on disk and if there is, it creates a `.shouldUninstall` file
                  as a marker. If that exists, we uninstall the app and clean up
                */
                const uninstallMarkerPath = path.join(pathToAppDirectory, ".shouldUninstall");
                const shouldUninstall = fs.existsSync(uninstallMarkerPath);
                this._log("debug", "Does Squirrel.Windows uninstall marker exist?", shouldUninstall, uninstallMarkerPath);
                if (shouldUninstall) {
                    yield execa(path.join(pathToAppDirectory, "Update.exe"), [
                        "--uninstall",
                        "-s",
                    ]);
                    yield del(pathToAppDirectory, { force: true });
                    this._log("info", "Successfully removed Squirrel.Windows app");
                }
            }
            catch (e) {
                // Ignore; there's not much we can do at this point
                this._log("debug", "Failed to remove Squirrel.Windows app");
                this._log("debug", e);
            }
        });
    }
}
exports.UpdaterAgent = UpdaterAgent;
class SquirrelWindowsUpdaterAgent {
    constructor({ log, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    logger, }) {
        this._log = (level, ...args) => log(level, "SquirrelWindowsUpdaterAgent:", ...args);
        if (process.platform !== "win32") {
            throw new Error("Only Windows is supported");
        }
        const config = (0, getConfig_1.default)();
        if (config.wasBuiltByUs) {
            throw new Error("App was built by us, this is unsupported");
        }
        // Can't get it to stop complaining that it doesn't recognize URLSearchParams
        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
        // @ts-ignore
        const params = new URLSearchParams({
            arch: process.arch,
            currentVersion: electron.app.getVersion(),
            platform: "windows",
        });
        [
            "before-quit-for-update",
            "checking-for-update",
            "error",
            "update-available",
            "update-downloaded",
            "update-not-available",
        ].forEach((eventName) => {
            // eslint-disable-next-line
            // @ts-ignore
            electron.autoUpdater.on(eventName, (...args) => this._log("debug", `autoUpdater event: ${eventName}`, ...args));
        });
        /*
          NOTE: Squirrel.Windows will still append /RELEASES to the
          path and it can append other query parameters too
        */
        electron.autoUpdater.setFeedURL({
            url: `https://dl.todesktop.com/${config.id}/squirrel?${params}`,
        });
    }
    /*
      This wrangles the Electron autoUpdater API into our shape.
      We listen to events, trigger a check, wait for a "final" event, unsubscribe,
      and return the result (asynchronously).
    */
    checkAndDownload() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const onError = (err) => {
                    // eslint-disable-next-line @typescript-eslint/no-use-before-define
                    removeListeners();
                    reject(err);
                };
                const onUpdateDownloaded = (event, releaseNotes, releaseName, releaseDate, updateURL) => {
                    // eslint-disable-next-line @typescript-eslint/no-use-before-define
                    removeListeners();
                    /*
                      If we can't grab the version from the URL, then just return a fake
                      version that's higher than the current version.
                      The server will only respond if the update is actually newer, so the
                      only issue is if the API user decides to show the version in the UI,
                      it'll be incorrect.
                      That's not so bad compared to auto-updates failing because the URL
                      pattern changed and our runtime library broke (nothing the user can
                      see / control).
                    */
                    const version = this._getVersionFromNupkgUrl(updateURL) ||
                        semver.inc(electron.app.getVersion(), "patch");
                    resolve({
                        releaseDate: releaseDate.toString(),
                        version,
                    });
                };
                const onUpdateNotAvailable = () => {
                    // eslint-disable-next-line @typescript-eslint/no-use-before-define
                    removeListeners();
                    resolve(null);
                };
                const removeListeners = once(() => {
                    electron.autoUpdater.off("error", onError);
                    electron.autoUpdater.off("update-downloaded", onUpdateDownloaded);
                    electron.autoUpdater.off("update-not-available", onUpdateNotAvailable);
                });
                electron.autoUpdater.once("error", onError);
                electron.autoUpdater.once("update-downloaded", onUpdateDownloaded);
                electron.autoUpdater.once("update-not-available", onUpdateNotAvailable);
                try {
                    // This auto-downloads (and the version comparison is automatic)
                    electron.autoUpdater.checkForUpdates();
                }
                catch (e) {
                    onError(e);
                }
            });
        });
    }
    restartAndInstall() {
        electron.autoUpdater.quitAndInstall();
    }
    setFeedURL(options) {
        electron.autoUpdater.setFeedURL(options);
    }
    /*
      Expects something like: https://example.com/My%20major%20app%202-0.0.2-rc.11-full.nupkg
      Pulls out the 0.1.2-rc.0 if it can.
    */
    _getVersionFromNupkgUrl(url) {
        // From https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string
        const officialSemverRegex = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
        // Remove the ^ and $
        const modifiedSemverRegexString = officialSemverRegex.source
            .replace(/^\^/, "")
            .replace(/\$$/, "");
        // Wrap the semver pattern in parentheses and append the expected nupkg filename suffix
        const matches = url.match(new RegExp(`(${modifiedSemverRegexString})-full\\.nupkg$`));
        if (matches) {
            return matches[1];
        }
    }
}
exports.SquirrelWindowsUpdaterAgent = SquirrelWindowsUpdaterAgent;
