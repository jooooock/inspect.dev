"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuiltInSources = void 0;
// eslint-disable-next-line @typescript-eslint/ban-ts-ignore
// @ts-ignore
const electron = require("electron");
const electronUpdater = require("electron-updater");
const eventemitter2_1 = require("eventemitter2");
const fs = require("fs");
const path = require("path");
const getConfig_1 = require("./getConfig");
const setTimeout_1 = require("./setTimeout");
const updaterAgents_1 = require("./updaterAgents");
const version_1 = require("./version");
var BuiltInSources;
(function (BuiltInSources) {
    BuiltInSources["autoCheckOnLaunch"] = "auto-check-on-launch";
    BuiltInSources["autoCheckOnInterval"] = "auto-check-on-interval";
    BuiltInSources["programmaticCall"] = "programmatic-call";
})(BuiltInSources = exports.BuiltInSources || (exports.BuiltInSources = {}));
class AutoUpdater extends eventemitter2_1.EventEmitter2 {
    constructor({ autoCheckInterval = 10 * 60 * 1000, // 10 min
    logger, shouldAutoCheckOnLaunch = true, }) {
        super();
        this._createdAt = Date.now();
        this._hasAppFinishedLaunching = false;
        this._hasUpdateReadyToInstall = false;
        this._isActive = true;
        this._pendingCheckSources = [];
        this._logger = logger;
        let inactiveReason = "";
        if (!electron.app.isPackaged) {
            this._isActive = false;
            inactiveReason = "application is not packaged";
        }
        if (process.platform === "linux" && !process.env.APPIMAGE) {
            this._isActive = false;
            inactiveReason = "application is not in AppImage";
        }
        if (this._isActive) {
            this._initializeUpdaterAgent();
        }
        else {
            const message = `@todesktop/runtime: skipping autoUpdater initialization because ${inactiveReason}.`;
            console.log(message);
            this._log("info", message);
        }
        electron.app.on("will-finish-launching", () => {
            this._log("debug", "electron will-finish-launching event emitted", {
                appVersion: electron.app.getVersion(),
                runtimeVersion: version_1.CLIENT_VERSION,
            });
            this._hasAppFinishedLaunching = true;
            if (!this._isActive) {
                return;
            }
            if (autoCheckInterval > 0) {
                this._autoCheckOnInterval(autoCheckInterval);
            }
            if (shouldAutoCheckOnLaunch) {
                this._autoCheckOnLaunch();
            }
        });
        this._subscribeToElectronEvents();
    }
    checkForUpdates({ source = BuiltInSources.programmaticCall, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this._log("info", ".checkForUpdates called");
            if (!this._hasAppFinishedLaunching) {
                const error = new Error("Cannot checkForUpdates before app is ready (see https://www.electronjs.org/docs/api/app#event-ready)");
                this._log("error", error);
                throw error;
            }
            if (!this._isActive) {
                return {
                    updateInfo: null,
                };
            }
            return yield this._check({ source });
        });
    }
    restartAndInstall({ isSilent = false, } = {}) {
        this._log("info", ".restartAndInstall called, isSilent: " + !!isSilent);
        if (!this._hasUpdateReadyToInstall) {
            const error = new Error("Cannot restart and install. There is no update downloaded");
            this._log("error", error);
            throw error;
        }
        this._log("debug", "Calling electron-updater's .quitAndInstall, isSilent: " + !!isSilent);
        if (isSilent) {
            /**
             * The API name `restartAndInstall` implies that the app will be restarted.
             * Therefore, we always restart the app and `isForceRunAfter` is always `true`.
             */
            this._updaterAgent.restartAndInstall(true, true);
        }
        else {
            this._updaterAgent.restartAndInstall();
        }
    }
    setFeedURL(options) {
        this._updaterAgent.setFeedURL(options);
    }
    _actuallyPerformCheck() {
        return __awaiter(this, void 0, void 0, function* () {
            this._log("debug", "_actuallyPerformCheck called");
            const updateInfo = yield this._updaterAgent.checkAndDownload();
            // Reset the collected sources
            const previouslyPendingCheckSources = [
                ...this._pendingCheckSources,
            ];
            this._pendingCheckSources = [];
            // No update available; exit early
            if (!updateInfo) {
                this._log("debug", "No update available");
                // To be safe
                this._hasUpdateReadyToInstall = false;
                return {
                    updateInfo,
                };
            }
            this._log("debug", "Update available", updateInfo);
            this._hasUpdateReadyToInstall = true;
            // Emit the event
            const eventPayload = {
                sources: previouslyPendingCheckSources,
                updateInfo,
            };
            this._log("debug", "Emitting update-downloaded event");
            Promise.race([
                this.emitAsync("update-downloaded", eventPayload),
                new Promise((r) => {
                    this._log("debug", "before notify call in setTimeout");
                    setTimeout(r, 500);
                }),
            ])
                .then((emitResult) => {
                if (!Array.isArray(emitResult) || !emitResult.includes(false)) {
                    this._log("debug", "calling notify after event listener Promise settled");
                    this.emit("notify-after-update-downloaded", eventPayload);
                }
            })
                .catch((e) => {
                this._log("debug", "Error occurred in update-downloaded handler", e);
                this.emit("notify-after-update-downloaded", eventPayload);
            });
            // Reset the collected sources
            this._pendingCheckSources = [];
            // Return as soon as possible (don't wait for listener responses)
            return { updateInfo };
        });
    }
    _autoCheckOnInterval(interval) {
        const checkAfterTimeout = () => {
            this._log("debug", "checking for update on interval");
            (0, setTimeout_1.default)(() => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield this._check({
                        source: BuiltInSources.autoCheckOnInterval,
                    });
                    checkAfterTimeout();
                }
                catch (e) {
                    this._log("error", e);
                    // Ignore and continute to check on interval
                    checkAfterTimeout();
                }
            }), interval);
        };
        checkAfterTimeout();
    }
    _autoCheckOnLaunch() {
        return __awaiter(this, void 0, void 0, function* () {
            this._log("debug", "checking for update on launch");
            try {
                yield this._check({
                    source: BuiltInSources.autoCheckOnLaunch,
                });
            }
            catch (e) {
                this._log("error", e);
                // Ignore. Auto-check on interval and programmatic API still supported
            }
        });
    }
    _check({ source, }) {
        return __awaiter(this, void 0, void 0, function* () {
            /*
              We collect the sources and emit them with the update-downloaded event.
              Other noteworthy bits:
              - The update check promise is reused by electron-updater.
              - We don't want more than one event emitted.
              - There's no sorting or de-duplication of the sources, on purpose.
            */
            this._pendingCheckSources.push(source);
            this._log("debug", "_check called", {
                source,
                pendingCheckSources: this._pendingCheckSources,
            });
            if (this._pendingUpdateCheckPromise) {
                return this._pendingUpdateCheckPromise;
            }
            const onEnd = () => {
                this._pendingUpdateCheckPromise = null;
            };
            this._pendingUpdateCheckPromise = this._actuallyPerformCheck()
                .then((updateCheckResult) => {
                onEnd();
                return updateCheckResult;
            })
                .catch((e) => {
                onEnd();
                throw e;
            });
            return this._pendingUpdateCheckPromise;
        });
    }
    /*
      Why are there UpdaterAgent classes?
  
      To transition apps to us, specifically Squirrel.Windows apps, we need
      to use electron-updater. They put runtime in their app, built with
      their existing tooling/infrastructure, then runtime will point to
      a Squirrel.Windows on our server which will actually use an NSIS
      installer and transition them.
  
      For Mac apps not built by us, we can use electron-updater but we need
      to make sure we point to our server.
    */
    _initializeUpdaterAgent() {
        if (process.platform === "win32" &&
            !(0, getConfig_1.default)().wasBuiltByUs &&
            // This is the official way to detect Squirrel.Windows
            fs.existsSync(path.join(electron.app.getAppPath(), "../Update.exe"))) {
            this._log("debug", "Setting up SquirrelWindowsUpdaterAgent");
            this._updaterAgent = new updaterAgents_1.SquirrelWindowsUpdaterAgent({
                log: (level, ...args) => {
                    this._log(level, "SquirrelWindowsUpdaterAgent:", ...args);
                },
                logger: this._logger,
            });
            return;
        }
        this._log("debug", "Setting up UpdaterAgent");
        this._updaterAgent = new updaterAgents_1.UpdaterAgent({
            log: (level, ...args) => {
                this._log(level, "UpdaterAgent:", ...args);
            },
            logger: this._logger,
        });
    }
    _log(level, ...args) {
        let firstArgument;
        if (process.env.AVA_PATH) {
            let timeSinceCreatedAt;
            // This can fail when there's a ReferenceError in a test and Date is overwritten
            try {
                timeSinceCreatedAt = ` (${Date.now() - this._createdAt}ms)`;
            }
            catch (e) {
                // Ignore
            }
            firstArgument = `AutoUpdater (${electron.app.name})${timeSinceCreatedAt}:`;
        }
        else {
            firstArgument = "AutoUpdater:";
        }
        this._logger[level](firstArgument, ...args);
    }
    _subscribeToElectronEvents() {
        electron.autoUpdater.on("before-quit-for-update", (...args) => {
            this._log("info", "before-quit-for-update");
            this.emit("before-quit-for-update", ...args);
        });
        electronUpdater.autoUpdater.on("checking-for-update", () => {
            this._log("info", "checking-for-update");
            this.emit("checking-for-update");
        });
        electronUpdater.autoUpdater.on("download-progress", (info) => {
            this._log("info", "download-progress", info);
            this.emit("download-progress", info);
        });
        electronUpdater.autoUpdater.on("update-available", (info) => {
            this._log("info", "update-available", info);
            this.emit("update-available", info);
        });
        electronUpdater.autoUpdater.on("update-not-available", (info) => {
            this._log("info", "update-not-available", info);
            this.emit("update-not-available", info);
        });
    }
}
exports.default = AutoUpdater;
