{"version":3,"file":"LighthouseProtocolService.js","sourceRoot":"","sources":["../../../../../front_end/lighthouse/LighthouseProtocolService.js"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2018 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../common/common.js';\nimport * as ProtocolClient from '../protocol_client/protocol_client.js';  // eslint-disable-line no-unused-vars\nimport * as SDK from '../sdk/sdk.js';\nimport * as Services from '../services/services.js';  // eslint-disable-line no-unused-vars\n\nimport * as ReportRenderer from './LighthouseReporterTypes.js';  // eslint-disable-line no-unused-vars\n\nexport class ProtocolService extends Common.ObjectWrapper.ObjectWrapper {\n  constructor() {\n    super();\n    /** @type {?ProtocolClient.InspectorBackend.Connection} */\n    this._rawConnection = null;\n    /** @type {?Services.ServiceManager.Service} */\n    this._backend = null;\n    /** @type {?Promise<void>} */\n    this._backendPromise = null;\n    /** @type {?function(string):void} */\n    this._status = null;\n  }\n\n  /**\n   * @return {!Promise<void>}\n   */\n  async attach() {\n    await SDK.SDKModel.TargetManager.instance().suspendAllTargets();\n    const mainTarget = SDK.SDKModel.TargetManager.instance().mainTarget();\n    if (!mainTarget) {\n      throw new Error('Unable to find main target required for LightHouse');\n    }\n    const childTargetManager = mainTarget.model(SDK.ChildTargetManager.ChildTargetManager);\n    if (!childTargetManager) {\n      throw new Error('Unable to find child target manager required for LightHouse');\n    }\n    this._rawConnection = await childTargetManager.createParallelConnection(message => {\n      if (typeof message === 'string') {\n        message = JSON.parse(message);\n      }\n      this._dispatchProtocolMessage(message);\n    });\n  }\n\n  getLocales() {\n    return navigator.languages;\n  }\n\n  /**\n   * @param {string} auditURL\n   * @param {!Array<string>} categoryIDs\n   * @param {!Object} flags\n   * @return {!Promise<!ReportRenderer.RunnerResult>}\n   */\n  startLighthouse(auditURL, categoryIDs, flags) {\n    const locales = this.getLocales();\n    return this._send('start', {url: auditURL, categoryIDs, flags, locales});\n  }\n\n  /**\n   * @return {!Promise<void>}\n   */\n  async detach() {\n    await this._send('stop');\n    if (this._backend) {\n      await this._backend.dispose();\n      this._backend = null;\n    }\n    this._backendPromise = null;\n    if (this._rawConnection) {\n      await this._rawConnection.disconnect();\n    }\n    await SDK.SDKModel.TargetManager.instance().resumeAllTargets();\n  }\n\n  /**\n   *  @param {function (string): void} callback\n   */\n  registerStatusCallback(callback) {\n    this._status = callback;\n  }\n\n  /**\n   * @param {(!Object)} message\n   */\n  _dispatchProtocolMessage(message) {\n    // A message without a sessionId is the main session of the main target (call it \"Main session\").\n    // A parallel connection and session was made that connects to the same main target (call it \"Lighthouse session\").\n    // Messages from the \"Lighthouse session\" have a sessionId.\n    // Without some care, there is a risk of sending the same events for the same main frame to Lighthouse–the backend\n    // will create events for the \"Main session\" and the \"Lighthouse session\".\n    // The workaround–only send message to Lighthouse if:\n    //   * the message has a sessionId (is not for the \"Main session\")\n    //   * the message does not have a sessionId (is for the \"Main session\"), but only for the Target domain\n    //     (to kickstart autoAttach in LH).\n    const protocolMessage = /** @type {{sessionId?: string, method?: string}} */ (message);\n    if (protocolMessage.sessionId || (protocolMessage.method && protocolMessage.method.startsWith('Target'))) {\n      this._send('dispatchProtocolMessage', {message: JSON.stringify(message)});\n    }\n  }\n\n  _initWorker() {\n    const backendPromise =\n        Services.serviceManager.createAppService('lighthouse_worker', 'LighthouseService').then(backend => {\n          if (this._backend) {\n            return;\n          }\n          this._backend = backend;\n          if (backend) {\n            backend.on(\n                'statusUpdate',\n                /**\n                 * @param {?=} result\n                 */\n                result => {\n                  if (this._status && result && 'message' in result) {\n                    this._status(result.message);\n                  }\n                });\n            backend.on(\n                'sendProtocolMessage',\n                /**\n                 * @param {?=} result\n                 */\n                result => {\n                  if (result && 'message' in result) {\n                    this._sendProtocolMessage(result.message);\n                  }\n                });\n          }\n        });\n    this._backendPromise = backendPromise;\n    return backendPromise;\n  }\n\n  /**\n   * @param {string} message\n   */\n  _sendProtocolMessage(message) {\n    if (this._rawConnection) {\n      this._rawConnection.sendRawMessage(message);\n    }\n  }\n\n  /**\n   * @param {string} method\n   * @param {!Object<string,*>=} params\n   * @return {!Promise<!ReportRenderer.RunnerResult>}\n   */\n  async _send(method, params) {\n    let backendPromise = this._backendPromise;\n    if (!backendPromise) {\n      backendPromise = this._initWorker();\n    }\n\n    await backendPromise;\n    if (!this._backend) {\n      throw new Error('Backend is missing to send LightHouse message to');\n    }\n    return /** @type {!Promise<!ReportRenderer.RunnerResult>} */ (this._backend.send(method, params));\n  }\n}\n"]}